陈利人先生就leetcode问题Largest Rectangle In Histogram提出扩展,
tim9216给出了其解决算法和源码, 于此说明:

sorry, but no english description. (shang-hai mostly uses chinese)

by  tim9216,  tim9216,  tim9216,  求上海挨踢职位,  通过姬媚儿联系

leetcode原题"the largest rectangle in histogram":
http://leetcode.com/problems/largest-rectangle-in-histogram

陈利人对问题扩展:
http://www.weibo.com/1915548291/DCEHQ9wa8


首先, 假设已经选定好三维柱状图里的一个固定的局部区域, 
[其底面也是长方形, 但(可能)只是原三维柱状图的部分底面], 
考虑完整完整完整覆盖该区域的最大长方体体积,
因该区域已经已经已经选定, 故其底面积确定, 
于是整个局部区域的最大长方体受限于该局部区域内最低的条柱高度.
[若不然, 长方体在最低条柱的对应位置高出, 不符题目的"围合"条件].

该条柱是整个区域内最低的, 所以也必然是其所在行[选定区域内的截段]最低的.
考察区域限定范围内的每一行, 他们都分别有各自的最低条柱.
最大体积的长方体也必然不高于任何一行的行内最低条柱, 
于是, 针对已经选定的某个区域, 求解完整覆盖该区域的最大长方体体积, 
只需要考虑内每一行的最低条柱. 换言之, 各行内部的其他较高条柱都暂可忽视.

现在我们强行命令每一行内部的相对较高条柱透明消失, 而最短条柱染色保持可见,
从侧面观察[视线顺沿行方向], 在选定区域内, 每一行上仅存留有该行的最低条柱, 
这些各行存留的行内最低条柱沿着行方向投射, 
在列方向上形成二维柱状图[图平面是选定区域的侧面].
应用已给出的针对原本问题的算法, 可得该侧面二维柱状图围得最大长方形面积,
又, 此侧面二维柱状图实质上在视线方向[行方向]具有深度[就是选定区域的宽度],
用所求的最大长方形面积乘以区域宽度[区域事先选定, 宽度定死不变], 
即得完全覆盖该区域的最大体积.

下面讨论如何在三维柱状图的整个完全底面上选取局部区域:
考虑宽度, 在每一行上, 所选区域的范围可以是:
始于第x个元素(i取值从 0 到 width-1 ), 并且
终于第x个元素(跨度0), 或终于第x+1, 或终于x+2 ... 或终于width-1个元素
( 相应跨度为 1,2 ... width-x-1 ),
行方向上不同的始末组合数量为: width * ( width-1 ) / 2 
类似, 列方向始末组合数量为: length * ( length-1 ) / 2

列列列方向上作出不同始末组合, 意图是求解各个组合范围中的,
侧面二维柱状图围出的, 最大大大长方形面积. 
根据这些组合范围得到的侧面柱状图, 
既涵盖了完整范围[始于第0行, 终于第length-1行]对应的的"完全侧面柱状图",
也涵盖了所有根据较小组合范围[跨度较小,行数较少]生成的"部分侧面柱状图".
实际上, 若从某完整二维柱状图截取部分, 形成"部分柱状图", 
完整原图所围成的最大长方形, 面积必然大于等于子图部分围出的结果.
因此不必一一计算"部分侧面柱状图"围出的最大长方形面积, 
仅根据行数最大的区域[始于第0行, 终于第length-1行]生成的"完全侧面柱状图",
算出其最大长方形即可, 必然大于等于"部分侧面柱状图"[与较小组合范围对应].

但行行行方向上作不同始末组合, 意在每一行选取各个组合范围内的最低低低条柱, 
跟上述的列方向的计算目的不同, 行方向的组合为求局部最小值, 
只有一一穷尽所有可能的行内全部始末组合, 也就是行内局部范围, 才能求得.

综上, 求解过程: 于整个三维柱状图的底面,
在各行上, 穷尽所有行内始末组合, 以求得每一个行内局部范围的条柱最小高度值,
各行内计算复杂度O(w*w), 全图共l行, 全过程复杂度O(w*w*l);
然后在列方向上, 抽取各行相对应的始末组合范围内的最小高度值,
[组合数量w*(w-1)/2, 复杂度O(w*w)], 视作二维柱状图[侧面], 
求围得最大长方形面积[单次求解复杂度O(l), 求解所有组合总复杂度O(w*w*l)],
再乘以对应局部区域的宽度[也是始末组合的宽度], 即得最大长方体体积.
以上, w为三维柱状图底面宽度width, l为长度length.

by  tim9216,  tim9216,  tim9216,  求上海挨踢职位,  通过姬媚儿联系

下面, 代码分析, 以C++为例: 接口是largestCuboidVolume, 
接受基于双重vector的矩阵origin_height, 元素值为三维柱状图高度.
由于宽度width决定复杂度的两阶, 
为效率起见,如果传入矩阵的宽度大于长度,则作转置, 见注释MATRIX TRANSITION处

height是引用, 若发生转置则另以局部变量存放转置结果, height指向该转置结果;
若无需转置, 则height直接指向原本传入的矩阵, 避免内存开销, 见height定义处.

valley基于变长的三重vector, 存放各行内部的,全部始末组合的,分别的最低高度.
valley[y][x][s]表示, 第y行中,始于第x个元素,终于第x+s个[包含x+s,跨度为s],
valley[y][x][s]的值, 就是y行中从x到x+s这个范围的最低值[包含x+s, 跨度为s]

valley求值过程是(下文略作v, 见注释VALLEY LOOPS处): 
在每一行[y循环], 遍历各个起始位置[x循环], 穷尽所有可能跨度[span循环], 
x循环意在求出一个数组, 该整个数组存放于v[y][x], 其成员为
v[y][x][0],  v[y][x][1],  v[y][x][2]  ...  v[y][x][width-x-1], 表示
y行上, 始于第x个元素, 跨度为0(终于x+0), 跨度1(终于x+1), 跨度2(终于x+2)
... 跨度 width-x-1 (终于width-1) 的各个组合范围内的, 分别的最低高度.

于每个起始位置x, 先以low记录三位柱状图的y行x列的元素作为最低值, 
在span循环内[span作为跨度], 每轮循环跨度加一, 
组合范围扩增, 起始位置x不变, 终结位置位移一步, 纳入一新元素[即高度值],
low与新纳入的元素[高度值]比较, 维持最低值, 再赋予v[y][x][span].
从而保证其 low = v[y][x][span] 是y行上, x到x+span这个范围内最小值. 注意:
1. reserve预先分配内存,避免多次push_back导致内存增长引发重分配而降低效率;
2. 没用min_element方法,因其效率O(w*w*w)不及给出方法[扩增同时维持low低值].

最后, valleys_in_aligned_range历经各行对应的始末组合范围[x/span双重循环],
分别汇聚不同始末组合范围的行内最低值, 见注释SEARCH VERTICAL HISTOGRAM处. 
调用largestRectangleArea[原问题的算法]求出侧面二维柱状图围成的最大长方形,
其结果再乘以宽度span+1, 于是, 局部区域围出的最大长方体蓄势待发. 
题目扩展所求的全局最大体积, 在所有这些局部最大长方体中必居其一.
各个体积逐一比较取最大, 全局最大脱颖而出, 至此, 最终答案手到擒來.


by  tim9216,  tim9216,  tim9216,  求上海挨踢职位,  通过姬媚儿联系
