关于陈利人提出的leetcode问题扩展形式Largest Rectangle In Histogram的算法\源码说明:

by  tim9216,  tim9216,  tim9216,  求上海IT职位

leetcode原题"the largest rectangle in histogram":
http://leetcode.com/problems/largest-rectangle-in-histogram

陈利人对问题扩展:
http://www.weibo.com/1915548291/DCEHQ9wa8

首先, 假定已经选定好三维柱状图里的某些行列所构成的一个固定的局部区域, 
考虑完整完整完整覆盖该区域的最大长方体体积,
因底面区域已经已经已经选定, 故底面积确定, 
于是体积受限于由该区域内最低的条柱高度.

该条柱是整个区域内最低的, 所以也必然是其所在行[选定区域内的截段]最低的.
考察区域限定范围内的每一行, 各行都分别有自己的最低条柱.
最大体积的长方体必然不高于任何一行中的最低条柱, 
[否则长方体在最低条柱的对应位置高出, 不符题目的"围合"条件].
于是针对已经选定的某个区域, 求解完整覆盖该区域的最大长方体体积, 
只需要考虑内每一行的最短条柱. 换言之, 每一行的非最短条柱都暂无计算价值.

现在我们强行命令每一行的非最短条柱透明消失, 而最短条柱染色保持可见,
从侧面观察(视线顺沿行方向), 在区域中, 每一行上仅有最低条柱存留, 
这些存留的条柱在列方向上构成二维柱状图.
应用前面已给出的针对原问题的算法, 求得该二维柱状图围得最大长方形面积,
又, 此二维柱状图实质上在视线方向[行方向]具有深度, 也就是选定区域的宽度.
将求得最大面积乘以区域宽度[区域事先选定, 宽度定死不变], 即得最大体积.

下面讨论如何在三维柱状图的整个底面上选取区域:
考虑宽度, 在每一行上, 所选区域的范围可以是:
始始始于第i个元素(i取值从 0 到 width-1 ), 
终终终于第i个元素(跨度0), 又或终于第i+1, i+2... width-1个( 跨度1,2... width-i-1 ),
行方向上不同的始末组合数量为: width * ( width-1 ) / 2 
类似, 列方向上始末组合数量为: length * ( length-1 ) / 2

然而实际上, 原问题的情形是二维柱状图, 若从完整的二维柱状图截出部分, 形成"子柱状图", 
完整原图所围成的最大长方形, 面积必然大于等于部分子图围出的结果.
而列列列方向上作不同始末组合, 正是意在求解各个组合范围上的二维柱状图的最大长方形面积, 
既涵盖了最大的完整范围[始于0, 终于length-1, 跨度length-1], 也涵盖了其所有部分子图, 
部分子图的围出结果, 必然小于等于完整范围的围出结果, 不必逐一求解, 仅算最大范围即可.

但行行行方向上作不同始末组合, 意在每一行选取各组合范围的最小小小高度条柱, 
只有一一穷尽所有始末组合才能求出.

综上, 求解过程: 对于整个三位柱状图的底面,
在每一行上, 穷尽所有始末组合, 求得每一个组合内的条柱最小高度值, 
行内过程复杂度O(w*w), 全图共l行, 全过程复杂度O(w*w*l);
在列方向上, 将各行相对应的始末组合范围内的最小高度值抽取出来[组合数量w*(w-1)/2], 
视为二维柱状图, 求围得最大长方形面积, 再乘对应始末组合的宽度, 即得最大长方体体积. 
此过程复杂度O(w*w*l),
其中w为三位柱状图底面宽度width, l为长度length;


下面, 代码分析, 以C++为例:
largestCuoidVolume接受基于双重vector的矩阵origin_height, 元素值为三维柱状图高度值.
注意到上述宽度width决定复杂度的两阶, 
因此, 若矩阵宽度大于长度则作转置, 见MATRIX TRANSITION处.

另, height为引用, 若发生转置,则生成一新矩阵[局部变量]存放转置结果, height指向该新矩阵;
若无需转置, 则height直接引用传入的原本矩阵, 避免内存开销, 见height定义处.

用不等长的三重vector存放前述各行分别的全部始末组合内包含的最低高度,
valley[ y ][ x ][ s ]表示, 第y行上, 始于第x个元素,终于第x+s个元素[包含x+s,范围跨度为s],
valley[ y ][ x ][ s ]的值, 就是y行中从x到x+s这个范围的最低值[包含x+s, 范围跨度为s]

valley求值过程是(下文略作v, 见VALLEY LOOPS处): 
在每一行[y循环], 遍历各个起始位置[x循环], 穷尽所有可能跨度[span循环], 
x循环意在求得数组v[y][x], 其成员为v[y][x][0], v[y][x][1] ... v[y][x][width-x-1]
表示y行上, 从第x个元素开始, 跨度为0(终于x+0), 跨度1(终于x+1), 跨度2(终于x+2)  ...  
跨度 width-x-1 (终于width-1) 的各个组合范围内的最低高度.

最初以low记录y行x列的元素作为最低值, 
在span循环内(span作为跨度), 每轮循环跨度加一, 即是组合范围扩增, 纳入一新元素[即高度值],
[起始位置x不变, 终结位置位移一步], low与新纳入的元素[高度值]比较, 维持最低值, 
再赋予valley[y][x][span], 从而保证其为是y行上, x到x+span这范围内最小值.
注意reserve一处是预先分配内存, 避免多次push_back导致内存增长引发内存重分配而降低效率. 

最后提取各行的对应的始末组合上的最低值, 见SEARCH VERTICAL HISTOGRAM处, x和span双重循环.
列方向上[y循环]应用前面的算法, 求解二维柱状图围成最大长方形[调用largestRectangleArea], 
结果乘以宽度span+1, 即得选定范围的最大体积.  所有选定最大体积相比较, 得所求全局最大.

by  tim9216,  tim9216,  tim9216,  求上海IT职位
