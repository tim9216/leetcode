陈利人先生就leetcode问题Largest Rectangle In Histogram提出扩展,
tim9216给出了其解决算法和源码, 于此说明:

sorry, but no english description. (shang-hai mostly uses chinese)

by  tim9216,  tim9216,  tim9216,  求上海挨踢职位,  通过姬媚儿联系

leetcode原题"the largest rectangle in histogram":
http://leetcode.com/problems/largest-rectangle-in-histogram

陈利人对问题扩展:
http://www.weibo.com/1915548291/DCEHQ9wa8


首先, 假设已经选定好三维柱状图里的某个固定的局部区域, 
[其底面也是长方形, 但(可能)只是原三维柱状图的部分底面], 
考虑完整完整完整覆盖该选定区域的最大长方体体积,
因该区域已经已经已经选定, 故其底面积确定, 
于是该整个选定局部区域的最大长方体受限于该区域内最低条柱的高度.
[若不然, 长方体在最低条柱的对应位置高出, 不符题目的"围合"条件].

该条柱是局部区域内最低的, 所以也必然是其所在行[局部区域内的截段]最低的.
考察局部区域范围内的每一行, 他们都分别有各自的最低条柱.
最大体积的长方体也必然不高于任何一行的行内最低条柱, 
于是, 针对已经选定的某个区域, 要算出完整覆盖该选定区域的最大长方体体积, 
只需考虑内每一行的最低条柱. 换言之, 各行内部的其他较高条柱都暂可忽视.

现在我们强行命令每一行内部的相对较高条柱透明消失, 而最短条柱染色保持可见,
从侧面观察[视线顺沿行方向], 在选定区域内, 每一行上仅存留有该行的最低条柱, 
这些各行存留的行内最低条柱沿着行方向投射, 
在列方向上形成二维柱状图[图平面是选定区域的侧面].
应用已给出的针对原本问题的算法, 可得该侧面二维柱状图围得最大长方形面积,
又, 此侧面二维柱状图实质上在视线方向[行方向]具有深度[就是选定区域的宽度],
用所求的最大长方形面积乘以区域宽度[区域事先选定, 宽度定死不变], 
即得完全覆盖该选定区域的最大体积.

下面讨论如何在三维柱状图的整个完全底面上选取局部区域:
考虑宽度, 在每一行上, 所选区域的范围可以是:
始于第x个元素(i取值从 0 到 width-1 ), 并且
终于第x个元素(跨度0), 或终于第x+1, 或终于x+2 ... 或终于width-1个元素
( 相应跨度为 1,2 ... width-x-1 ),
行方向上不同的始末组合数量为: width * ( width-1 ) / 2 
类似, 列方向始末组合数量为: length * ( length-1 ) / 2

列列列方向上作出不同始末组合, 意图是求解各个始末组合范围中的,
侧面二维柱状图围出的, 最大大大长方形面积. 
根据这些始末组合范围得到的侧面柱状图, 
既涵盖了最大的完整范围[始于第0行, 终于第length-1行]对应的"完全侧面柱状图",
也涵盖了所有根据较小组合范围[跨度较小,行数较少]对应的"部分侧面柱状图".
实际上, 若从某完整二维柱状图截取部分, 形成其"部分柱状图", 
完整原图所围出的最大长方形, 面积必然大于等于部分子图的围成结果.
因此不必一一计算"部分侧面柱状图"围出的最大长方形面积, 
仅根据行数最大的区域[始于第0行, 终于第length-1行]对应的"完全侧面柱状图",
算出其最大长方形即可, 必然大于等于"部分侧面柱状图"[对应较小组合区域范围]

但行行行方向上作不同始末组合, 跟上述列方向上的计算意图不同, 
是为了求局部最小值, 在每一行上分别选取各个起始组合范围内的最低低低条柱, 
只有一一穷尽所有可能的行内全部始末组合, 也就是行内所有局部范围, 才能求得.

综上, 求解过程: 于整个三维柱状图的底面,
在各行上, 穷尽所有行内始末组合, 以求出每一个行内局部范围的最小高度,
各行行内计算复杂度O(w*w), 完整底面共有l行, 全过程复杂度O(w*w*l);
然后沿着列方向, 在相对应的行内始末组合范围里, 抽取该范围的各行的最小高度,
视作二维柱状图[侧面], [其中组合数量w*(w-1)/2, 复杂度O(w*w)],
解出围得最大长方形面积[单次求解复杂度O(l), 求解所有组合总复杂度O(w*w*l)],
再乘以对应局部区域的宽度[也是始末组合的宽度], 即得最大长方体体积.
以上, w为三维柱状图底面宽度width, l为长度length.

by  tim9216,  tim9216,  tim9216,  求上海挨踢职位,  通过姬媚儿联系

下面, 代码分析, 采用C++: 接口是largestCuboidVolume, 
接受基于双重vector的矩阵origin_height, 元素值为三维柱状图高度.
由于宽度width决定复杂度的两阶, 为效率起见, 如果传入矩阵的宽度大于长度,
则作转置, 见注释MATRIX TRANSITION处

height是引用, 若发生转置,则另以局部变量存放转置结果, height指向该结果;
若无需转置,则height直接指向传入的矩阵, 避免额外内存开销, 见height定义处.

valley基于变长的三重vector, 存放各行内部的,全部始末组合范围内的最低高度.
valley[y][x][s]的值, 表示y行中从x到x+s这个范围的最低值[包含x+s, 跨度为s]

valley求值过程是(下文略作v, 见注释VALLEY LOOPS处): 
在每一行[y循环], 遍历各个起始位置[x循环], 穷尽所有可能跨度[span循环], 
x循环意在求出一个数组, 该整个数组存放于v[y][x], 其成员为
v[y][x][0],  v[y][x][1],  v[y][x][2]  ...  v[y][x][width-x-1], 分别表示
y行上, 始于第x个元素, 跨度为0(终于x+0), 跨度1(终于x+1), 跨度2(终于x+2)
... 跨度 width-x-1 (终于width-1) 的各个始末组合范围内的, 分别的最低高度.

于每个起始位置x, 先以low记录三维柱状图的y行x列的元素作为最低值, 
在span循环内[span为跨度], 每轮循环跨度加一, 组合范围扩增, 
起始位置x不变, 终结位置位移一步, 纳入一新元素[即高度值],
low与新纳入的元素[高度值]比较, 维持最低值, 再赋予v[y][x][span].
从而保证其 low = v[y][x][span] 是y行上, x到x+span这个范围内最小值. 注意:
1.reserve预先分配内存,避免多次push_back导致内存增长引发重分配而降低效率;
2.避免使用std::min_element函数, 其将行内计算操作的效率降低为O(w*w*w), 
  不及给出方法[扩增过程中同时维持low低值, 复杂度O(w*w)].

最后,依次分别在所有行内始末组合的范围里[x/span双重循环], 
以valleys_in_aligned_range从每一行汇聚该范围的各自行内最低值[y循环], 
见注释SEARCH VERTICAL HISTOGRAM处.  
调largestRectangleArea[原问题的算法]求出侧面二维柱状图围成的最大长方形
其结果再乘以宽度span+1, 于是, 局部区域围出的最大长方体蓄势待发. 
题目扩展所求的全局最大体积, 在所有这些局部最大长方体中必居其一.
各局部最大体积逐一比较取最大, 全局最大脱颖而出, 至此, 最终答案手到擒來.

by  tim9216,  tim9216,  tim9216,  求上海挨踢职位,  通过姬媚儿联系
